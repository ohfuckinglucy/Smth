typedef enum: Это объявление перечисления, которое будет использоваться для хранения цвета узлов 
(красный или черный) в красно-чёрном дереве.

struct rbtree: Объявляется структура для узлов красно-чёрного дерева. Каждый узел содержит:
key: Ключ узла, по которому будет происходить сравнение.
value: Значение, связанное с ключом (строка).
color: Цвет узла (красный или черный).
left, right: Указатели на левого и правого потомков.
parent: Указатель на родителя узла.

create_node: Создает новый узел.
malloc: Выделяет память для нового узла.
key: Присваивается ключ.
strdup(value): Копирует строку value и присваивает её узлу.
color: Новый узел всегда создается красным.
left, right, parent: Инициализируются как NULL (новый узел изначально не имеет потомков и родителя).
Возвращает указатель на созданный узел.

left_rotate: Выполняет левый поворот узла x. Это важная операция для поддержания сбалансированности дерева.
y = x->right: Узел y становится правым потомком узла x.
x->right = y->left: Левый потомок y становится правым потомком x.
y->parent = x->parent: Обновляется родитель y, чтобы указывать на родителя x.
if (x->parent == NULL): Если x был корнем дерева, то y становится новым корнем.
y->left = x: x становится левым потомком y.
x->parent = y: Родителем x становится y.

right_rotate: Аналогично левому повороту, но в другую сторону. Здесь y — узел, для которого выполняется поворот вправо.

rbtree_add_fixup: Эта функция восстанавливает красно-чёрные свойства дерева после добавления нового узла.
Если родитель нового узла node красный, то есть нарушение свойств дерева, и выполняются определенные действия:
Если дядя узла тоже красный, перекрашиваем узлы.
Если дядя черный, выполняем повороты для восстановления баланса.

rbtree_add: Функция для добавления нового узла в красно-чёрное дерево.
Если ключ уже существует, обновляется его значение.
Если ключ не найден, создается новый узел, который затем вставляется в дерево.
После добавления выполняется вызов rbtree_add_fixup для восстановления свойств красно-чёрного дерева.

rbtree_lookup: Функция для поиска узла по ключу. Если узел с указанным ключом найден, возвращается его указатель. Иначе возвращается NULL.

rbtree_min: Возвращает узел с минимальным ключом в дереве (самый левый узел).

rbtree_max: Возвращает узел с максимальным ключом в дереве (самый правый узел).

free_rbtree: Рекурсивная функция для освобождения памяти, занятой красно-чёрным деревом.
Сначала освобождаются левый и правый потомки (если они существуют).
Затем освобождается память, выделенная под значение узла (node->value).
После этого освобождается сам узел (node).

print_rbtree: Рекурсивная функция для печати дерева. Выводится ключ узла, его значение, а также цвет (красный или черный).
Сперва печатается правое поддерево с увеличением глубины на каждом уровне.
for (int i = 0; i < depth; i++): Печатаются отступы для визуализации уровня вложенности узла.
Затем выводится текущий узел с его ключом, значением и цветом.
После этого печатается левое поддерево.

Удаление узла в красно-чёрном дереве состоит из нескольких этапов, включая удаление самого узла, 
замену его потомков и возможную перестройку дерева, чтобы сохранить его свойства. 
Удаление достаточно сложное, так как требует также корректировать баланс дерева.

rbtree_delete_fixup: Функция восстановления красно-чёрных свойств дерева после удаления узла.
В зависимости от того, является ли узел левым или правым потомком, 
алгоритм корректирует баланс дерева. Если обнаруживается нарушение красно-чёрных свойств, 
выполняются повороты (левый или правый) и перекраска узлов, чтобы восстановить баланс.

rbtree_delete: Основная функция для удаления узла из красно-чёрного дерева.
Сначала выполняется поиск узла по ключу с помощью rbtree_lookup.
Затем алгоритм корректирует дерево в зависимости от того, есть ли у узла потомки.
Если один из потомков отсутствует, узел заменяется его потомком.
Если оба потомка существуют, выполняется поиск минимального элемента в правом поддереве для замены удаляемого узла.
После замены удаляемого узла может потребоваться восстановление красно-чёрных свойств с помощью rbtree_delete_fixup.

rbtree_transplant: Эта функция заменяет один узел u другим узлом v.
Если u — корень дерева, то v становится новым корнем.
Если u — левый потомок своего родителя, то v становится новым левым потомком.
Если u — правый потомок, то v становится правым потомком.
Если v не NULL, его родитель обновляется, чтобы указывать на родителя u.